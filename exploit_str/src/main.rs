/*
   Copyright 2024 Aedan Kearns

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*/
use const_format::formatcp;
use std::{
    env,
    fs::{self, File},
    io::{stdin, stdout, BufWriter, Read, Write},
    process::ExitCode,
};

const NAME: &'static str = env!("CARGO_PKG_NAME");
const VER: &'static str = env!("CARGO_PKG_VERSION");
const AUTHORS: &'static str = env!("CARGO_PKG_AUTHORS");
const DESC: &'static str = env!("CARGO_PKG_DESCRIPTION");
#[cfg(target_os = "windows")]
const WIN_WARN: &'static str =
    "\nWARNING: Outputting invalid UTF-8 to standard output isn't possible. File output still works. (This is a limitation of Windows)";
#[cfg(not(target_os = "windows"))]
const WIN_WARN: &'static str = "";
const USAGE: &'static str = formatcp!(
"{NAME} v{VER}
    by {AUTHORS}
{DESC}

Usage: exploit_str args...

Arguments are buffered in order, but aren't written until all have been parsed.{WIN_WARN}

Any argument that takes in a formatted string allows for simple escaping with the following:
    \\n     LF
    \\t     TAB
    \\\\     backslash
    \\x00   Hex byte, must be two digits. Invalid unicode allowed

Arguments:
    EXPR            =>  String: writes formatted string EXPR

    -r  EXPR COUNT  =>  Repeat: repeats formatted string EXPR COUNT times

    -fN COUNT       =>  Fill: sequentially fills count blocks of bitwidth N (or 32 if omitted) with looping capital letters
        example: exploit_str -f32 8 => AAAABBBBCCCCDDDDEEEEFFFFGGGGHHHH
    -fbN COUNT      =>  Fill bytes: Same as -f except COUNT is the total number of bytes, rounded up
        example: exploit_str -fb32 7 => AAAABBBB

    -b  EXPR        =>  Byte string: Writes unformatted string
    -xN HEX         =>  Hex values: Writes hexadecimal values of bitwidth N, converted to little endian.
        Can be a single value or a whitespace separated list surrounded by quotation marks

    -i              =>  In: reads in formatted string from standard input until EOF
    -ib             =>  In bytes: reads raw bytes from standard input until EOF
    -ixN            =>  In hex: reads hex values from standard input as similar to -x (but without quotes) until EOF

    -if PATH        =>  In file: reads in formatted string from file of PATH
    -ifb PATH       =>  In file bytes: reads in raw bytes from file of PATH
    -ifx PATH       =>  In file hex: reads in hex values as in -ix from file of PATH

    -o  PATH        =>  Outfile: writes output to file instead of standard output

    -h              =>  Help: prints this text"
);

#[inline(always)]
fn write_out(out: &mut impl Write, to_write: &[u8]) -> Result<(), String> {
    if let Err(e) = out.write_all(to_write) {
        Err(format!("Failed to write to buffer: {e:#?}"))
    } else {
        Ok(())
    }
}

fn write_char_out(out: &mut impl Write, c: char) -> Result<(), String> {
    let mut buf = [0u8; 4];
    let len = c.encode_utf8(&mut buf).len();
    write_out(out, &buf[..len])
}

fn write_str_out(out: &mut impl Write, append: &String) -> Result<(), String> {
    let mut iter = append.char_indices();
    'outer: loop {
        let (_, chr) = match iter.next() {
            Some(v) => v,
            None => break 'outer,
        };
        match chr {
            '\\' => match iter.next() {
                Some((i, ch)) => match ch {
                    'n' => write_out(out, &['\n' as u8])?,
                    't' => write_out(out, &['\t' as u8])?,
                    '\\' => write_out(out, &['\\' as u8])?,
                    'x' => match u8::from_str_radix(&append[i..i + 2], 16) {
                        Ok(v) => write_out(out, &[v])?,
                        Err(e) => {
                            return Err(format!("Failed to parse hex escape: {e:#?}"));
                        }
                    },
                    _ => {
                        return Err(format!("Unsupported escape \"\\{ch}\""));
                    }
                },
                None => {
                    return Err("String ended with unfinished escape".into());
                }
            },
            c => write_char_out(out, c)?,
        }
    }
    Ok(())
}

fn write_hex_str_out(out: &mut impl Write, width: u8, string: &String) -> Result<(), String> {
    for hex_str in string.trim().split_whitespace() {
        match width {
            1 => match u8::from_str_radix(hex_str, 16) {
                Ok(v) => write_out(out, &[v])?,
                Err(e) => {
                    return Err(format!(
                        "Failed to write hex value 0x{hex_str} with error {e:#?}"
                    ));
                }
            },
            2 => match u16::from_str_radix(hex_str, 16) {
                Ok(v) => write_out(out, &v.to_le_bytes())?,
                Err(e) => {
                    return Err(format!(
                        "Failed to write hex value 0x{hex_str} with error {e:#?}"
                    ));
                }
            },
            4 => match u32::from_str_radix(hex_str, 16) {
                Ok(v) => write_out(out, &v.to_le_bytes())?,
                Err(e) => {
                    return Err(format!(
                        "Failed to write hex value 0x{hex_str} with error {e:#?}"
                    ));
                }
            },
            8 => match u64::from_str_radix(hex_str, 16) {
                Ok(v) => write_out(out, &v.to_le_bytes())?,
                Err(e) => {
                    return Err(format!(
                        "Failed to write hex value 0x{hex_str} with error {e:#?}"
                    ));
                }
            },
            _ => {
                return Err("Unsupported hex value width".into());
            }
        }
    }
    Ok(())
}

enum OutputType {
    Fill { width: u8, bytes: bool, count: u64 },
    Repeat { s: String, count: u64 },
    In,
    InHex { width: u8 },
    InBytes,
    Str(String),
    HexStr { width: u8, string: String },
    Bytes(Vec<u8>),
}

#[inline(always)]
fn check_result<T, E: std::fmt::Debug>(res: Result<T, E>, msg: &str) -> Result<T, String> {
    match res {
        Ok(v) => Ok(v),
        Err(e) => Err(format!("{msg} with error {e:#?}")),
    }
}
#[inline(always)]
fn check_option<T>(res: Option<T>, msg: &'static str) -> Result<T, String> {
    match res {
        Some(v) => Ok(v),
        None => Err(msg.into()),
    }
}

fn main() -> ExitCode {
    match run() {
        Ok(()) => ExitCode::SUCCESS,
        Err(string) => {
            eprintln!("{string}");
            ExitCode::FAILURE
        }
    }
}

fn run() -> Result<(), String> {
    let mut args = env::args();
    if args.len() < 2 {
        println!("{USAGE}");
        return Ok(());
    }
    args.next();

    let mut outputs = Vec::new();
    let mut outfile: Option<String> = None;

    'outer: loop {
        let arg = match args.next() {
            Some(s) => s,
            None => break 'outer,
        };
        match arg.chars().next().unwrap() {
            '-' => {
                if arg.starts_with("-f") {
                    let mut width = 4;
                    if arg.len() > 2 {
                        if arg.chars().nth(2).unwrap() == 'b' {
                            if arg.len() > 3 {
                                width = check_result(
                                    arg[3..].parse::<u8>(),
                                    "Unable to parse fill width",
                                )? / 8;
                            }
                            let count = check_result(
                                check_option(args.next(), "Unspecified fill count")?.parse(),
                                "Unable to parse fill count",
                            )?;
                            outputs.push(OutputType::Fill {
                                width,
                                bytes: true,
                                count,
                            });
                            continue 'outer;
                        }
                        width =
                            check_result(arg[2..].parse::<u8>(), "Unable to parse fill width")? / 8;
                    }
                    let count = check_result(
                        check_option(args.next(), "Unspecified fill count")?.parse(),
                        "Unable to parse fill count",
                    )?;
                    outputs.push(OutputType::Fill {
                        width,
                        bytes: false,
                        count,
                    });
                } else if arg.starts_with("-x") {
                    let width =
                        check_result(arg[2..].parse::<u8>(), "Unable to parse hex width")? / 8;
                    outputs.push(OutputType::HexStr {
                        width,
                        string: check_option(args.next(), "Missing hex value")?,
                    });
                } else if arg.starts_with("-ix") {
                    let width = check_result(
                        arg[2..].parse::<u8>(),
                        "Unable to parse standard in hex width",
                    )? / 8;
                    outputs.push(OutputType::InHex { width });
                } else if arg.starts_with("-ifx") {
                    let width =
                        check_result(arg[2..].parse::<u8>(), "Unable to parse file in hex width")?
                            / 8;
                    let path = check_option(args.next(), "Missing hex in file name")?;
                    let string = check_result(
                        fs::read_to_string(&path),
                        format!("Failed to read file {path}").as_str(),
                    )?;
                    outputs.push(OutputType::HexStr { width, string })
                } else {
                    match arg.as_str() {
                        "-o" => {
                            if outfile.is_some() {
                                return Err("Multiple output files not supported".into());
                            }
                            outfile = Some(check_option(args.next(), "Output file not specified")?);
                        }
                        "-r" => {
                            let string = check_option(args.next(), "Missing repeat string")?;
                            let count = check_result(
                                check_option(args.next(), "Missing repeat count")?.parse(),
                                "Unable to parse repeat count",
                            )?;
                            outputs.push(OutputType::Repeat { s: string, count })
                        }
                        "-i" => outputs.push(OutputType::In),
                        "-if" => {
                            let path = check_option(args.next(), "Missing in file name")?;
                            let string = check_result(
                                fs::read_to_string(&path),
                                format!("Failed to read file {path}").as_str(),
                            )?;
                            outputs.push(OutputType::Str(string));
                        }
                        "-b" => {
                            outputs.push(OutputType::Bytes(
                                check_option(args.next(), "Missing byte string")?.into_bytes(),
                            ));
                        }
                        "-ib" => outputs.push(OutputType::InBytes),
                        "-ifb" => {
                            let path = check_option(args.next(), "Missing in file name")?;
                            let bytes = check_result(
                                fs::read(&path),
                                format!("Failed to read file {path}").as_str(),
                            )?;
                            outputs.push(OutputType::Bytes(bytes));
                        }
                        "-h" => {
                            println!("{USAGE}");
                            return Ok(());
                        }
                        arg => {
                            return Err(format!("Unknown argument \"{arg}\""));
                        }
                    }
                }
            }
            _ => outputs.push(OutputType::Str(arg)),
        }
    }

    let mut out: BufWriter<Box<dyn Write>> = if let Some(filename) = &outfile {
        BufWriter::new(Box::new(check_result(
            File::create(filename),
            format!("Unable to create file {filename} for writing").as_str(),
        )?))
    } else {
        BufWriter::new(Box::new(stdout()))
    };

    for output in &outputs {
        match output {
            &OutputType::Fill {
                width,
                bytes,
                count,
            } => {
                let mut count = count;
                if bytes {
                    if count % width as u64 > 0 {
                        count += width as u64;
                    }
                    count /= width as u64;
                }
                for i in 0..count {
                    let to_write = vec![0x41 + (i % 26) as u8; width as usize];
                    write_out(&mut out, &to_write)?;
                }
            }
            OutputType::Repeat { s, count } => {
                for _ in 0..*count {
                    write_str_out(&mut out, s)?;
                }
            }
            OutputType::In => {
                let mut str = String::new();
                if let Err(e) = stdin().read_to_string(&mut str) {
                    return Err(format!("Read from standard in failed with error {e:#?}"));
                }
                write_str_out(&mut out, &str)?;
            }
            OutputType::InHex { width } => {
                let mut str = String::new();
                if let Err(e) = stdin().read_to_string(&mut str) {
                    return Err(format!("Read from standard in failed with error {e:#?}"));
                }
                write_hex_str_out(&mut out, *width, &str)?;
            }
            OutputType::InBytes => {
                let mut buf = Vec::new();
                if let Err(e) = stdin().read_to_end(&mut buf) {
                    return Err(format!("Read from standard in failed with error {e:#?}"));
                }
                write_out(&mut out, &buf)?;
            }
            OutputType::Str(append) => write_str_out(&mut out, append)?,
            OutputType::HexStr { width, string } => write_hex_str_out(&mut out, *width, string)?,
            OutputType::Bytes(bytes) => write_out(&mut out, &bytes)?,
        }
    }

    if let Err(e) = out.flush() {
        Err(format!(
            "Failed to flush buffer to output with error {e:#?}"
        ))
    } else {
        Ok(())
    }
}
